<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java]]></title>
    <url>%2F2018%2F10%2F17%2Fjava%2F</url>
    <content type="text"><![CDATA[Java 常用指令 javac – 编译.java源文件 java – 运行.class字节码文件 -jar javaw – 后台运行.class字节码文件 javap – 反编译.class字节码文件启动jar包程序： 1java -jar -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8004 coin-processor-btc*.jar 1&gt; btc-search.out 2&gt;btc-search.err &amp; Java存储 寄存器 stack（栈）预分配内存 heap（内存堆）：动态分配内存 方法区（常量池…..） 常数值 Java8新特性 stream 接口 方法声明，成员变量默认为static.final类型,可以有方法实现。称之为默认方法。使用default关键字函数式编程之函数式接口的应用 Function –apply() Consume –accept() Predicate –test()java8 Optional类 java.util.Optional类是一个封装了Optional值的==容器对象==，Optional值可以为null，如果值存在，调用isPresent()方法返回true，调用get()方法可以获取值. 创建Optional对象(静态方法) 1234如果函数返回所需的对象，请使用map;如果函数返回Optional，则使用flatMap。例如： -map : -flatMap : -filter empty() 用于创建一个没有值的Optional对象 of() 使用一个非空的值创建Optional对象 ofNullable() 如果str的值为null，得到的nullableOpt是一个没有值的Optional对象 使用orElse(&quot;&quot;)方法获取值如果有值就返回，否则返回一个给定的值作为默认值 orElseGet(() -&gt; func())：与orElse()方法作用类似，区别在于生成默认值的方式不同。该方法接受一个Supplier&lt;? extends T&gt;函数式接口参数，用于生成默认值 orElseThrow()：与前面介绍的get()方法类似，当值为null时调用这两个方法都会抛出NullPointerException异常，区别在于该方法可以指定抛出的异常类型 ifPresent(dosoming) :如果该optional对象不为null,执行dosomeing,否则什么都不做。 重要概念 IOC(控制反转): 控制反转是一种在软件工程中解耦合的思想，调用类只依赖接口，而不依赖具体的实现类，减少了耦合。控制权交给了容器，在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中 DI : 依赖注入(依赖注入是一种设计模式，可以作为控制反转的一种实现方式。依赖注入就是将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 依赖public class Human &#123; ... Father father; ... public Human() &#123; father = new Father(); &#125;&#125;// 问题1.如果现在要改变 father 生成方式，如需要用new Father(String name)初始化 father，需要修改 Human 代码；2.如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中；3.如果new Father()过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。// 依赖注入public class Human &#123; ... Father father; ... public Human(Father father) &#123; this.father = father; &#125;&#125;上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。现在我们发现上面例子 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处：1.解耦，将依赖之间解耦。2.因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。//完整例子class MovieLister... private MovieFinder finder; public void setFinder(MovieFinder finder) &#123; this.finder = finder; &#125;class ColonMovieFinder... public void setFilename(String filename) &#123; this.filename = filename; &#125; public void testWithSpring() throws Exception &#123; ApplicationContext ctx = new FileSystemXmlApplicationContext("spring.xml");//1 MovieLister lister = (MovieLister) ctx.getBean("MovieLister");//2 Movie[] movies = lister.moviesDirectedBy("Sergio Leone"); assertEquals("Once Upon a Time in the West", movies[0].getTitle());&#125;//ApplicationContext 即IOC容器//从容器中获取MovieLister实例 ``` ```xml &lt;beans&gt; &lt;bean id="MovieLister" class="spring.MovieLister"&gt; &lt;property name="finder"&gt; &lt;ref local="MovieFinder"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="MovieFinder" class="spring.ColonMovieFinder"&gt; &lt;property name="filename"&gt; &lt;value&gt;movies1.txt&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; spring aop (aspectj静态织入需要ajc编译器的支持) spring aop 运用==动态代理==(JDK动态代理底层靠【反射】CGLIB底层靠【继承】)实现动态注入. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public interface UserDao &#123; int addUser(); void updateUser(); void deleteUser(); void findUser();&#125;------------------import org.springframework.stereotype.Repository;@Repositorypublic class UserDaoImp implements UserDao &#123; public int addUser() &#123; System.out.println(&quot;add user ......&quot;); return 6666; &#125; public void updateUser() &#123; System.out.println(&quot;update user ......&quot;); &#125; public void deleteUser() &#123; System.out.println(&quot;delete user ......&quot;); &#125; public void findUser() &#123; System.out.println(&quot;find user ......&quot;); &#125;&#125;--------------------------------import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;@Aspectpublic class MyAspect &#123; /** * 前置通知 */ @Before(&quot;execution(* UserDao.addUser(..))&quot;) public void before()&#123; System.out.println(&quot;前置通知....&quot;); &#125; /** * 后置通知 * returnVal,切点方法执行后的返回值 */ @AfterReturning(value=&quot;execution(* UserDao.addUser(..))&quot;,returning = &quot;returnVal&quot;) public void AfterReturning(Object returnVal)&#123; System.out.println(&quot;后置通知....&quot;+returnVal); &#125; /** * 环绕通知 * @param joinPoint 可用于执行切点的类 * @return * @throws Throwable */ @Around(&quot;execution(* UserDao.addUser(..))&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(&quot;环绕通知前....&quot;); Object obj= (Object) joinPoint.proceed(); System.out.println(&quot;环绕通知后....&quot;); return obj; &#125; /** * 抛出通知 * @param e */ @AfterThrowing(value=&quot;execution(* UserDao.addUser(..))&quot;,throwing = &quot;e&quot;) public void afterThrowable(Throwable e)&#123; System.out.println(&quot;出现异常:msg=&quot;+e.getMessage()); &#125; /** * 无论什么情况下都会执行的方法 */ @After(value=&quot;execution(* UserDao.addUser(..))&quot;) public void after()&#123; System.out.println(&quot;最终通知....&quot;); &#125;&#125;--------------------------------import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= &quot;classpath:beans.xml&quot;)public class UserDaoAspectJ &#123; @Autowired UserDao userDao; @Test public void aspectJTest()&#123; userDao.addUser(); &#125;&#125;//输出环绕通知前....前置通知....add user ......环绕通知后....最终通知....后置通知....6666beans.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 启动@aspectj的自动代理支持--&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;!-- 定义目标对象 --&gt; &lt;bean id=&quot;userDaos&quot; class=&quot;UserDaoImp&quot;/&gt; &lt;!-- 定义aspect类 --&gt; &lt;bean name=&quot;myAspectJ&quot; class=&quot;MyAspect&quot;/&gt;&lt;/beans&gt; 泛型 : 泛型类 泛型接口 泛型方法(返回值前面加&lt;&gt;) 抽象类 有抽象方法的类 内部类（定义在类内部的类，作为类的成员变量） 重载(方法名相同，参数列表不同，与返回值无关) 重写(方法实现逻辑不同，其他完全一样) 类加载机制 类加载器(3种，双亲委托加载机制)（bootstrapClassLoder ,etcClassLoder ,appClassLoder） 初始化顺序：静态方法，静态变量，静态代码块，代码块，构造方法， final(一定会执行) finalize(垃圾回收) 多线程并发 创建线程的三种常用方法： 继承thread类 实现Runable接口(重写 run() 方法) Callable（重写call()方法） 和Future(接口类似于go里的context接口)（FutureTask)(实现了Runable和Future接口–&gt; 运行在子线程并且可控) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Test &#123; public static void main(String[] args) &#123; // Callable+FutureTask 获取执行结果 /* ExecutorService executor = Executors.newCachedThreadPool(); Task task = new Task(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task); executor.submit(futureTask); executor.shutdown();*/ //第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread /*Task task = new Task(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task); Thread thread = new Thread(futureTask); thread.start();*/ ExecutorService executorService = Executors.newCachedThreadPool(); Task task = new Task(); Future&lt;Integer&gt; result = executorService.submit(task); executorService.shutdown(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("主线程在执行任务"); try &#123; System.out.println("运行结果" + result.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println("所有任务执行完毕"); &#125;&#125;class Task implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println("子线程正在进行计算"); Thread.sleep(3000); int sum = 0; for (int i = 0; i&lt;100; i++) sum += i; return sum; &#125;&#125; ExecutorService(接口—&gt; Java中的线程池实现) Executors提供的四种线程 newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 123456789101112131415161718192021ExecutorService executorService = Executors.newCachedThreadPool();for(int i=0;i&lt;5;i++)&#123; final int index = i; try &#123; Thread.sleep(index * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; executorService.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + "," +index); &#125; &#125;);&#125;//控制台信息pool-1-thread-1,0pool-1-thread-1,1pool-1-thread-1,2pool-1-thread-1,3pool-1-thread-1,4 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 123456789101112131415161718192021ExecutorService fixedThreadPool = Executors.newFixedThreadPool(4);for(int i=0;i&lt;5;i++) &#123; final int index = i; fixedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + ", " + index); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125;//控制台信息pool-1-thread-1,0pool-1-thread-2,1pool-1-thread-3,2pool-1-thread-4,3pool-1-thread-1,4 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 123456789101112131415161718192021222324252627ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);System.out.println("before:" + System.currentTimeMillis()/1000);scheduledThreadPool.schedule(new Runnable() &#123; @Override public void run() &#123; System.out.println("延迟3秒执行的哦 :" + System.currentTimeMillis()/1000); &#125;&#125;, 3, TimeUnit.SECONDS);System.out.println("after :" +System.currentTimeMillis()/1000);//控制台信息before:1518012703after :1518012703延迟3秒执行的哦 :1518012706System.out.println("before:" + System.currentTimeMillis()/1000);scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; System.out.println("延迟1秒之后，3秒执行一次:" +System.currentTimeMillis()/1000); &#125;&#125;, 1, 3, TimeUnit.SECONDS);System.out.println("after :" +System.currentTimeMillis()/1000);控制台消息before:1518013024after :1518013024延迟1秒之后，3秒执行一次:1518013025延迟1秒之后，3秒执行一次:1518013028延迟1秒之后，3秒执行一次:1518013031 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 123456789101112131415161718192021ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();for (int i=0;i&lt;10;i++) &#123; final int index = i; singleThreadExecutor.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + "," + index); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125;控制台信息pool-1-thread-1,0pool-1-thread-1,1pool-1-thread-1,2pool-1-thread-1,3pool-1-thread-1,4 execute()和submit()区别 12345678910111213向线程池提交任务 ThreadPoolExecutor类中execute()和submit()区别 execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，通过源码查看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。/** * @throws RejectedExecutionException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; */public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125; 线程池关闭 123线程池的关闭 我们可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，但是它们的实现原理不同，shutdown的原理是只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。 线程的方法 1234wait(),notify()和notifyAll()都是java.lang.Object的方法：wait(): Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.notify(): Wakes up a single thread that is waiting on this object's monitor.notifyAll(): Wakes up all threads that are waiting on this object's monitor. 如果线程调用了对象的wait（）方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。 当有线程调用了对象的notifyAll（）方法（唤醒所有wait线程）或notify（）方法（只随机唤醒一个wait线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait（）方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁定池中的线程会继续竞争该对象锁 sleep（线程类方法） join ：主线程等待异步线程执行结束(线程类的方法) wait ：暂停，直到调用notify或者notifyAll（执行此命令要在与wait不同的线程中）（object类方法）只能在同步方法或同步块中调用wait（）方法 yield ：暂停一段时间 notify（object） notifyAll（object） daemon（后台启动） suspend（挂起后台进程） synchronized：同步方法、同步代码块（this）、同步静态代码块（.class） 竞态条件 ：当两个或者两个以上的线程同时对象同一变量操作，并且至少有一个写操作时，就会发生线程安全问题。 同步器 ConcurrentHashMap 锁 lock() , trylock() 信号量（Semaphore）123456public void acquire() throws InterruptedException &#123; &#125; //获取一个许可public void release() &#123; &#125; //释放一个许可public boolean tryAcquire() &#123; &#125;; //尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回falsepublic boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;; //尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回falsepublic boolean tryAcquire(int permits) &#123; &#125;; //尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回falsepublic boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;; //尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false 原子操作(automic类) 并发数据结构(BlockingQueue) CAS乐观锁 compareAndSet() CountDownLatch和CyclicBarrier(回环栅栏)123456CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的 maven 打包命令 mvn clean package slf4j 不能打印日志 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;!-- or use LATEST --&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;!-- or use LATEST --&gt;&lt;/dependency&gt; 指明Java版本 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; Eureka Eureka是Netflix开源的一款提供服务注册和发现的产品，它提供了完整的Service Registry和Service Discovery实现。也是springcloud体系中最重要最核心的组件之一。服务中心又称注册中心，管理各种服务功能包括服务的注册、发现、熔断、负载、降级等，比如dubbo admin后台的各种功能。 Eureka Server 提供服务注册和发现 Service Provider 服务提供方 将自身服务注册到Eureka，从而使服务消费方能够找到 Service Consumer 服务消费方 从Eureka获取注册服务列表，从而能够消费服务 Eureka Server ==所有的服务端及访问服务的客户端都需要连接到注册管理器（eureka服务器)== 1234567891011121314151617让服务使用eureka服务器，只需添加@EnableDiscoveryClient注解就可以了。回到我们在上篇文章中实现的cloud-simple-service微服务应用。在main方法所在的Application类中，添加@EnableDiscoveryClient注解。然后在配置文件中添加： eureka.client.serviceUrl.defaultZone=http\://localhost\:8761/eureka/ spring.application.name=cloud-simple-service其中defaultZone是指定eureka服务器的地址，无论是注册还是发现服务都需要这个地址。application.name是指定进行服务注册时该服务的名称这个名称就是后面调用服务时的服务标识符（这是服务发现的功能，我们在后面章节具体介绍）。当然，pom文件也需要增加： &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; 如此以来该服务启动后会自动注册到eureka服务器。如果在该服务中还需要调用别的服务，那么直接使用那个服务的服务名称加方法名构成的url即可 spring cloud已经帮我实现了服务注册中心，我们只需要很简单的几个步骤就可以完成。 pom中添加依赖 123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 启动代码中添加@EnableEurekaServer注解 12345678@SpringBootApplication@EnableEurekaServer //只需要使用@EnableEurekaServer注解就可以让应用变为Eureka服务器public class SpringCloudEurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringCloudEurekaApplication.class, args); &#125;&#125; 配置文件在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，在application.properties添加以下配置： 1234567spring.application.name=spring-cloud-eurekaserver.port=8000eureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.serviceUrl.defaultZone=http://localhost:$&#123;server.port&#125;/eureka/ eureka.client.register-with-eureka ：表示是否将自己注册到Eureka Server，默认为true。 eureka.client.fetch-registry ：表示是否从Eureka Server获取注册信息，默认为true。 eureka.client.serviceUrl.defaultZone ：设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。默认是http://localhost:8761/eureka ；多个地址可使用 , 分隔。启动工程后，访问：http://localhost:8000/，可以看到下面的页面，其中还没有发现任何服务 集群 Eureka通过互相注册的方式来实现高可用的部署，所以我们只需要将Eureke Server配置其他可用的serviceUrl就能实现高可用部署双节点注册中心首次我们尝试一下双节点的注册中心的搭建。 创建application-peer1.properties，作为peer1服务中心的配置，并将serviceUrl指向peer2 12345spring.application.name=spring-cloud-eurekaserver.port=8000eureka.instance.hostname=peer1eureka.client.serviceUrl.defaultZone=http://peer2:8001/eureka/ 创建application-peer2.properties，作为peer2服务中心的配置，并将serviceUrl指向peer1 12345spring.application.name=spring-cloud-eurekaserver.port=8001eureka.instance.hostname=peer2eureka.client.serviceUrl.defaultZone=http://peer1:8000/eureka/ host转换在hosts文件中加入如下配置 12127.0.0.1 peer1 127.0.0.1 peer2 打包启动依次执行下面命令 打包mvn clean package 分别以peer1和peeer2 配置信息启动eureka12java -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1java -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2 依次启动完成后，浏览器输入：http://localhost:8000/ 效果图如下： 根据图可以看出peer1的注册中心DS Replicas已经有了peer2的相关配置信息，并且出现在available-replicas中。我们手动停止peer2来观察，发现peer2就会移动到unavailable-replicas一栏中，表示peer2不可用。到此双节点的配置已经完成。 在生产中我们可能需要三台或者大于三台的注册中心来保证服务的稳定性，配置的原理其实都一样，将注册中心分别指向其它的注册中心。这里只介绍三台集群的配置情况，其实和双节点的注册中心类似，每台注册中心分别又指向其它两个节点即可，使用application.yml来配置。application.yml配置详情如下：123456789101112131415161718192021222324252627282930313233343536373839---spring: application: name: spring-cloud-eureka profiles: peer1server: port: 8000eureka: instance: hostname: peer1 client: serviceUrl: defaultZone: http://peer2:8001/eureka/,http://peer3:8002/eureka/---spring: application: name: spring-cloud-eureka profiles: peer2server: port: 8001eureka: instance: hostname: peer2 client: serviceUrl: defaultZone: http://peer1:8000/eureka/,http://peer3:8002/eureka/---spring: application: name: spring-cloud-eureka profiles: peer3server: port: 8002eureka: instance: hostname: peer3 client: serviceUrl: defaultZone: http://peer1:8000/eureka/,http://peer2:8001/eureka/ 分别以peer1、peer2、peer3的配置参数启动eureka注册中心。123java -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1java -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2java -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer3 依次启动完成后，浏览器输入：http://localhost:8000/ 效果图如下： 可以在peer1中看到了peer2、peer3的相关信息。至此eureka集群也已经完成了 spring boot 什么是spring boot 1Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是spring boot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架（不知道这样比喻是否合适）。 使用spring boot有什么好处其实就是简单、快速、方便！平时如果我们需要搭建一个spring web项目的时候需要怎么做呢？ 配置web.xml，加载spring和spring mvc 配置数据库连接、配置spring事务 配置加载配置文件的读取，开启注解 配置日志文件 … 配置完成之后部署tomcat 调试 … 现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我的项目仅仅是生产一个积分；我都需要这样折腾一遍!但是如果使用spring boot呢？很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套web项目或者是构建一个微服务！使用sping boot到底有多爽，用下面这幅图来表达 快速入门 说了那么多，手痒痒的很，马上来一发试试! maven构建项目 访问http://start.spring.io/ 选择构建工具Maven Project、Spring Boot版本1.3.6以及一些工程基本信息，点击“Switch to the full version.”java版本选择1.7，可参考下图所示： 点击Generate Project下载项目压缩包 解压后，使用eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt;选择解压后的文件夹-&gt; Finsh，OK done! 项目结构介绍 如上图所示，Spring Boot的基础结构共三个文件: src/main/java 程序开发以及主程序入口 src/main/resources 配置文件 src/test/java 测试程序另外，spingboot建议的目录结果如下：root package结构：com.example.myprojectcom1234567891011121314+- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- controller | +- CustomerController.java | Application.java 建议放到根目录下面,主要用于做一些框架配置 domain目录主要用于实体（Entity）与数据访问层（Repository） service 层主要是业务类代码 controller 负责页面访问控制采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改 最后，启动Application main方法，至此一个java项目搭建好了！ 引入web模块 1、pom.xml中添加支持web的模块：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; pom.xml文件中默认有两个模块： spring-boot-starter ：核心模块，包括自动配置支持、日志和YAML； spring-boot-starter-test ：测试模块，包括JUnit、Hamcrest、Mockito。 2、编写controller内容： 1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping("/hello") public String index() &#123; return "Hello World"; &#125;&#125; @RestController 的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！ 3、启动主程序，打开浏览器访问http://localhost:8080/hello，就可以看到效果了，有木有很简单！ 如何做单元测试 打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。123456789101112131415161718192021@RunWith(SpringRunner.class)@SpringBootTest(mian函数所在类.class) @SpringBootConfiguration // 换成这个成功public class HelloTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo("Hello World"))); &#125;&#125; 开发环境的调试 热启动在正常开发项目中已经很常见了吧，虽然平时开发web项目过程中，改动项目启重启总是报错；但springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置：12345678910111213141516171819 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。 总结 使用spring boot可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用sping boot非常适合构建微服务。 SpringBoot Mybatis mybatis-spring-boot-starter 注解版本 添加相关maven文件 1234567891011121314151617181920212223242526272829303132333435363738&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;``` 2. application.properties 添加相关配置```ymlmybatis.type-aliases-package=com.neo.entityspring.datasource.driverClassName = com.mysql.jdbc.Driverspring.datasource.url = jdbc:mysql://localhost:3306/test1?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username = rootspring.datasource.password = root 开发Mapper 第三步是最关键的一块，sql生产都在这里12345678910111213141516171819202122232425262728293031323334353637383940414243@Repository@Mapperpublic interface UserMapper &#123; @Select("SELECT * FROM users") @Results(&#123; @Result(property = "userSex", column = "user_sex", javaType = UserSexEnum.class), @Result(property = "nickName", column = "nick_name") &#125;) List&lt;UserEntity&gt; getAll(); //动态指定表名 @Select("SELECT * FROM $&#123;tableName&#125; WHERE id = #&#123;id&#125;") @Results(&#123; @Result(property = "userSex", column = "user_sex", javaType = UserSexEnum.class), @Result(property = "nickName", column = "nick_name") &#125;) UserEntity getOne(@Param("tablename") String tableName, @Param("id")Long id); @Insert("INSERT INTO users(userName,passWord,user_sex) VALUES(#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;userSex&#125;)") void insert(UserEntity user); @Update("UPDATE users SET userName=#&#123;userName&#125;,nick_name=#&#123;nickName&#125; WHERE id =#&#123;id&#125;") void update(UserEntity user); @Delete("DELETE FROM users WHERE id =#&#123;id&#125;") void delete(Long id);&#125; batchInset注解方式 @Insert("&lt;script&gt;"+ "insert into table(column1, column3, column2) " + "values " + "&lt;foreach collection =\"useridList\" item=\"userid\" index= \"index\" separator =\",\"&gt; " + "(#&#123;userid&#125;,#&#123;message.title&#125;,#&#123;message.content&#125;,#&#123;message.type&#125;,0,0,NOW()) " + "&lt;/foreach &gt; " + "&lt;/script&gt;")动态SQL@Select("&lt;script&gt;"+ "select id,coinType,coinName,LOWER(contractAddress) as contractAddress,tokenDecimals,currentBlockHeight,currentBalance,status" + " from tab_coin_list where 1=1" + " &lt;if test=\"name != null and name != ''\"&gt; and \"(coinType like \"%\"#&#123;name&#125;\"%\" or coinName like \"%\"#&#123;name&#125;\"%\")\"&lt;/if&gt;" + " &lt;/script&gt;") 1234567891011121314151617181920mybatis like 模糊查询--all 用$不能防sql注入 select * from user where name like &apos;%$&#123;name&#125;%&apos; --mysql,oracle （db2的concat函数只支持2个参数） select * from user where name like concat(&apos;%&apos;,#&#123;name&#125;,&apos;%&apos;) --oracle,db2 select * from user where name like &apos;%&apos;||#&#123;name&#125;||&apos;%&apos; （sqllite中可用）@Select(&quot;&lt;script&gt;&quot;+ &quot;select id,coinType,coinName,LOWER(contractAddress) as contractAddress,tokenDecimals,currentBlockHeight,currentBalance,status&quot; + &quot; from tab_coin_list &quot; + &quot; &lt;if test=\&quot;name != null and name != &apos;&apos;\&quot;&gt;where coinType like \&quot;%\&quot;||#&#123;name&#125;||\&quot;%\&quot; or coinName like \&quot;%\&quot;||#&#123;name&#125;||\&quot;%\&quot; &lt;/if&gt;&quot; + &quot; &lt;/script&gt;&quot;) --SQL Server select * from user where name like &apos;%&apos;+#&#123;name&#125;+&apos;%&apos; --据说这种是预编译，有空测下 select * from user where name like &quot;%&quot;#&#123;name&#125;&quot;%&quot; 1234567891011121314151617181920212223242526272829//mybatis 分页 依赖//&lt;dependency&gt; // &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; // &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; // &lt;version&gt;1.1.1&lt;/version&gt; // &lt;/dependency&gt; @Service @Transactional public class HelloServiceImpl &#123; @Autowired MybatisDao mybatisDao; public void find()&#123; //分页插件: 查询第1页，每页10行 Page&lt;User&gt; page =PageHelper.startPage(1, 10); mybatisDao.findAll(); //数据表的总行数 page.getTotal(); //分页查询结果的总行数 page.size(); //第一个User对象，参考list，序号0是第一个元素，依此类推 page.get(0); &#125; // 执行原理：PageHelper.startPage会拦截下一个sql//，也就是mybatisDao.findAll()的SQL。并且根据当前数据库的语法，把这个SQL改造成一个高性能的分页SQL，同时还会查询该表的总行数，具体可以看SQL日志。//PageHelper.startPage和mybatisDao.findAll()最好紧跟在一起，中间不要有别的逻辑，否则可能出BUG。//Page&lt;User&gt; page：相当于一个list集合，findAll()方法查询完成后，会给page对象的相关参数赋值 为了更接近生产我特地将user_sex、nick_name两个属性在数据库加了下划线和实体类属性名不一致，另外user_sex使用了枚举 ● @Select 是查询类的注解，所有的查询均使用这个 ● @Result 修饰返回的结果集，关联实体类属性和数据库字段一一对应，如果实体类属性和数据库属性名保持一致，就不需要这个属性来修饰。 ● @Insert 插入数据库使用，直接传入实体类会自动解析属性到对应的值 ● @Update 负责修改，也可以直接传入对象 ● @delete 负责删除 注意，使用#符号和$符号的不同：1234567// This example creates a prepared statement, something like select * from teacher where name = ?; // 防sql注入@Select("Select * from teacher where name = #&#123;name&#125;")Teacher selectTeachForGivenName(@Param("name") String name);// This example creates n inlined statement, something like select * from teacher where name = 'someName';@Select("Select * from teacher where name = '$&#123;name&#125;'")Teacher selectTeachForGivenName(@Param("name") String name); 手動建表 使用上面三步就基本完成了相关dao层开发，使用的时候当作普通的类注入进入就可以了12345678910111213141516171819202122232425262728293031@RunWith(SpringRunner.class)@SpringBootTest(value = main.class)public class UserMapperTest &#123; @Autowired private UserMapper UserMapper; @Test public void testInsert() throws Exception &#123; UserMapper.insert(new UserEntity("aa", "a123456", UserSexEnum.MAN)); UserMapper.insert(new UserEntity("bb", "b123456", UserSexEnum.WOMAN)); UserMapper.insert(new UserEntity("cc", "b123456", UserSexEnum.WOMAN)); Assert.assertEquals(3, UserMapper.getAll().size()); &#125; @Test public void testQuery() throws Exception &#123; List&lt;UserEntity&gt; users = UserMapper.getAll(); System.out.println(users.toString()); &#125; @Test public void testUpdate() throws Exception &#123; UserEntity user = UserMapper.getOne(3l); System.out.println(user.toString()); user.setNickName("neo"); UserMapper.update(user); Assert.assertTrue(("neo".equals(UserMapper.getOne(3l).getNickName()))); &#125;&#125; 极简xml版本极简xml版本保持映射文件的老传统，优化主要体现在不需要实现dao的是实现层，系统会自动根据方法名在映射文件中找对应的sql. 配置pom文件和上个版本一样，只是application.properties新增以下配置12mybatis.config-locations=classpath:mybatis/mybatis-config.xmlmybatis.mapper-locations=classpath:mybatis/mapper/*.xml 指定了mybatis基础配置文件和实体类映射文件的地址mybatis-config.xml 配置12345678910111213&lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias alias="Integer" type="java.lang.Integer" /&gt; &lt;typeAlias alias="Long" type="java.lang.Long" /&gt; &lt;typeAlias alias="HashMap" type="java.util.HashMap" /&gt; &lt;typeAlias alias="LinkedHashMap" type="java.util.LinkedHashMap" /&gt; &lt;typeAlias alias="ArrayList" type="java.util.ArrayList" /&gt; &lt;typeAlias alias="LinkedList" type="java.util.LinkedList" /&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 这里也可以添加一些mybatis基础的配置 添加User的映射文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;mapper namespace="com.neo.mapper.UserMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.neo.entity.UserEntity" &gt; &lt;id column="id" property="id" jdbcType="BIGINT" /&gt; &lt;result column="userName" property="userName" jdbcType="VARCHAR" /&gt; &lt;result column="passWord" property="passWord" jdbcType="VARCHAR" /&gt; &lt;result column="user_sex" property="userSex" javaType="com.neo.enums.UserSexEnum"/&gt; &lt;result column="nick_name" property="nickName" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, userName, passWord, user_sex, nick_name &lt;/sql&gt; &lt;select id="getAll" resultMap="BaseResultMap" &gt; SELECT &lt;include refid="Base_Column_List" /&gt; FROM users &lt;/select&gt; &lt;select id="getOne" parameterType="java.lang.Long" resultMap="BaseResultMap" &gt; SELECT &lt;include refid="Base_Column_List" /&gt; FROM users WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insert" parameterType="com.neo.entity.UserEntity" &gt; INSERT INTO users (userName,passWord,user_sex) VALUES (#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;userSex&#125;) &lt;/insert&gt; &lt;update id="update" parameterType="com.neo.entity.UserEntity" &gt; UPDATE users SET &lt;if test="userName != null"&gt;userName = #&#123;userName&#125;,&lt;/if&gt; &lt;if test="passWord != null"&gt;passWord = #&#123;passWord&#125;,&lt;/if&gt; nick_name = #&#123;nickName&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; &lt;delete id="delete" parameterType="java.lang.Long" &gt; DELETE FROM users WHERE id =#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 其实就是把上个版本中mapper的sql搬到了这里的xml中了 编写Dao层的代码12345678910111213public interface UserMapper &#123; List&lt;UserEntity&gt; getAll(); UserEntity getOne(Long id); void insert(UserEntity user); void update(UserEntity user); void delete(Long id);&#125; 对比上一步这里全部只剩了接口方法 使用 使用和上个版本没有任何区别，大家就看代码吧 如何选择 两种模式各有特点，注解版适合简单快速的模式，其实像现在流行的这种微服务模式，一个微服务就会对应一个自已的数据库，多表连接查询的需求会大大的降低，会越来越适合这种模式。老传统模式比适合大型项目，可以灵活的动态生成SQL，方便调整SQL，也有痛痛快快，洋洋洒洒的写SQL的感觉。 字符串与16进制互转 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.io.ByteArrayOutputStream;public class StringUtils &#123; public static String toHexString(String s) &#123; String str = ""; for (int i = 0; i &lt; s.length(); i++) &#123; int ch = (int) s.charAt(i); String s4 = Integer.toHexString(ch); str = str + s4; &#125; return str; &#125; // 转化十六进制编码为字符串 public static String toStringHex1(String s) &#123; byte[] baKeyword = new byte[s.length() / 2]; for (int i = 0; i &lt; baKeyword.length; i++) &#123; try &#123; baKeyword[i] = (byte) (0xff &amp; Integer.parseInt(s.substring( i * 2, i * 2 + 2), 16)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; try &#123; s = new String(baKeyword, "utf-8");// UTF-16le:Not &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; return s; &#125; // 转化十六进制编码为字符串 public static String toStringHex2(String s) &#123; byte[] baKeyword = new byte[s.length() / 2]; for (int i = 0; i &lt; baKeyword.length; i++) &#123; try &#123; baKeyword[i] = (byte) (0xff &amp; Integer.parseInt(s.substring( i * 2, i * 2 + 2), 16)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; try &#123; s = new String(baKeyword, "utf-8");// UTF-16le:Not &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; return s; &#125; /* * 16进制数字字符集 */ private static String hexString = "0123456789ABCDEF"; /* * 将字符串编码成16进制数字,适用于所有字符（包括中文） */ public static String encode(String str) &#123; // 根据默认编码获取字节数组 byte[] bytes = str.getBytes(); StringBuilder sb = new StringBuilder(bytes.length * 2); // 将字节数组中每个字节拆解成2位16进制整数 for (int i = 0; i &lt; bytes.length; i++) &#123; sb.append(hexString.charAt((bytes[i] &amp; 0xf0) &gt;&gt; 4)); sb.append(hexString.charAt((bytes[i] &amp; 0x0f) &gt;&gt; 0)); &#125; return sb.toString(); &#125; /* * 将16进制数字解码成字符串,适用于所有字符（包括中文） */ public static String decode(String bytes) &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream( bytes.length() / 2); // 将每2位16进制整数组装成一个字节 for (int i = 0; i &lt; bytes.length(); i += 2) baos.write((hexString.indexOf(bytes.charAt(i)) &lt;&lt; 4 | hexString .indexOf(bytes.charAt(i + 1)))); return new String(baos.toByteArray()); &#125; public static void main(String[] args) &#123; // System.out.println(encode("中文")); // System.out.println(decode(encode("中文"))); System.out.println(encode( "EOS51cNL8NbNygP8hyj4jg7Q8Dxw8PZCMwSpvtmbbdTxqenGQSdMq")); &#125; // 第二种方法：// 将指定byte数组以16进制的形式打印到控制台// 复制代码 代码如下:&#125; java Time包 JAVA 8 引入新时间API原因是原来的Date类无法支持多线程操作，新时间API支持多线程操作，当java.time包内时间类其值发生改变时，其如同String类，类的实例是不可变的对象，当改变其值的时候就会新生成对象地址，从而改变其对象地址，以保证支持多线程操作。 新的java.time包内类默认均采用ISO-8601时区标准 &lt;给计算机看的时间&gt; Instant 时间戳 在时间线上的瞬间点 在ISO- 2007-12-03T10:15:30-&gt; 2007-12-03T10:15:30 .000Z。&lt;自己使用的日期时间&gt; LocalDate 在ISO- 2007-12-03 -&gt; 2007-12-03 。 LocalDateTime 在ISO- 2007-12-03T10:15:30 -&gt; 2007-12-03T10:15:30 。 LocalTime 在ISO- 10:15:30 -&gt; 10:15:30 。 Duration 和Period Duration:用于计算两个“时间”间隔 Period:用于计算两个“日期”间隔1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package java8.time;import java.time.Duration;import java.time.Instant;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.Period;import java.time.ZoneId;import java.time.format.DateTimeFormatter;import java.util.Locale;import java.util.Set;import org.junit.Test;public class Demo &#123; /** * 计算时间差 */ @Test public void test1() &#123; Instant time1 = Instant.now(); // 获取系统当前 System.out.println(time1); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Instant time2 = Instant.now();// 获取休眠后系统时间 Duration duration = Duration.between(time1, time2); // 计算两个时间的差值 System.out.println(duration.toMillis()); &#125; @Test public void test2() &#123; LocalDateTime time1 = LocalDateTime.now(); System.out.println(time1); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; LocalDateTime time2 = LocalDateTime.now(); Duration duration = Duration.between(time1, time2); System.out.println(duration.toMillis()); &#125; /* * 计算两日期相差时间 */ @Test public void test3() &#123; LocalDate date1 = LocalDate.now(); LocalDate date2 = date1.plusDays(5); Period period = Period.between(date1, date2); System.out.println(period.getDays()); &#125; /* * 输入指定日期 按照指定日期格式输出 默认采用ISO-8601日历系统 */ @Test public void test4() &#123; LocalDateTime time = LocalDateTime.of(1997, 06, 13, 12, 59, 0); time = time.plusMinutes(1); DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd : hh:mm:ss"); String formatTime = formatter.format(time); System.out.println(formatTime); &#125; /* * 修改默认日期格式 */ @Test public void test5() &#123; // 获取所有日期格式 Set&lt;String&gt; set = ZoneId.getAvailableZoneIds(); // 获取所有亚洲国家时区 set.stream().filter(e -&gt; e.startsWith("Asia")).forEach(System.out::println); LocalDateTime time = LocalDateTime.now(ZoneId.of("Asia/Hong_Kong")); // format 第二个参数 指定国家 DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd : hh:mm:ss", Locale.CHINA); System.out.println(formatter.format(time)); System.out.println(time); &#125;&#125; 将多个子工程打进一个可运行的jar包 12345678910111213141516171819202122232425262728293031323334&lt;plugin&gt; &lt;!-- Build an executable JAR --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;mainClass&gt;Main&lt;/mainClass&gt; //指定main方法 &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; // 将多个jar打进一个jar中 &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!-- put your configurations here --&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 使用 JSON output 作为 toString() 的默认输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 @Override public String toString() &#123; return new Gson().toJson(this);&#125;1. Reflections (Apache library)@Overridepublic String toString()&#123; return org.apache.commons.lang3.builder.ReflectionToStringBuilder.toString(this);&#125;JSON based implementation (GSON, Jackson libraries)// GSON library for JSON@Overridepublic String toString()&#123; return new com.google.gson.Gson().toJson(this);&#125;// Jackson libabry for JSON/YAML@Overridepublic String toString() &#123; try &#123; return new com.fasterxml.jackson.databind.ObjectMapper().writerWithDefaultPrettyPrinter().writeValueAsString(this); &#125; catch (com.fasterxml.jackson.core.JsonProcessingException e) &#123; e.printStackTrace(); &#125; return null;&#125;2. ToStringBuilder (available with apache-commons library)@Overridepublic String toString() &#123; return new org.apache.commons.lang3.builder.ToStringBuilder(this). append("field1", field1). append("field2", field2). toString();&#125;3. Hard-core toString() implementation@Overridepublic String toString() &#123; return new StringBuilder() .append("field1:"+field1) .append("field2:"+field2) .toString();&#125; 使用BlockingQueue的关键技术点如下 BlockingQueue定义的常用方法如下: ==add(anObject)==:把anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则==抛出异常== ==offer(anObject)==:表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回==false==. ==put(anObject)==:把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被==阻塞==直到BlockingQueue里面有空间再继续. ==poll(time)==:取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null ==take()==:取走BlockingQueue里排在首位的对象,若BlockingQueue为空,==阻塞==进入等待状态直到Blocking有新的对象被加入为止 BlockingQueue有5个具体的实现类,根据不同需求,选择不同的实现类 ==ArrayBlockingQueue==:规定大小的BlockingQueue,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的.==有序固定大小== ==LinkedBlockingQueue==:大小不定的BlockingQueue,若其构造函数带一个规定大小的参数,生成的BlockingQueue有大小限制,若不带大小参数,所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定.其所含的对象是以FIFO(先入先出)顺序排序的==有序== ==PriorityBlockingQueue==:类似于LinkedBlockQueue,但其所含对象的排序不是FIFO,而是依据对象的自然排序顺序或者是构造函数的Comparator决定的顺序==自定义排序==. ==SynchronousQueue==:特殊的BlockingQueue,对其的操作必须是==放和取交替完成的==. ==DelayQueue== : Delayed 元素的一个无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部 是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且 poll 将返回 null。当一个元素的getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于或等于零的值时，则出现期满。此队列不允许使用 null 元素 LinkedBlockingQueue和ArrayBlockingQueue比较起来,它们背后所用的数据结构不一样,导致LinkedBlockingQueue的数据吞吐量要大于ArrayBlockingQueue,但在线程数量很大时其性能的可预见性低于ArrayBlockingQueue. SpringBot 注解 CommandLineRunner、ApplicationRunner 接口是在容器启动成功后的最后一步回调（类似开机自启动） java 内部类 分类 静态内部类 12341. 静态内部类不持有外部类的引用2. 静态内部类不依赖外部类 # 在普通内部类中，我们可以直接访问外部类的属性、方法，即使是private类型也可以访问，这是因为内部类持有一个外部类的引用，可以自由访问。而静态内部类，则只可以访问外部类的静态方法和静态属性（如果是private权限也能访问，这是由其代码位置所决定的），其他则不能访问 普通内部类1231. 普通内部类不能声明static的方法和变量# 普通内部类不能声明static的方法和变量，注意这里说的是变量，常量（也就是final static修饰的属性）还是可以的，而静态内部类形似外部类，没有任何限制。 作用 12345671.内部类可以很好的实现隐藏2．内部类拥有外围类的所有元素的访问权限3.可是实现多重继承4.可以避免修改接口而实现同一个类中两种同名方法的调用 maven 依赖传递问题 找出传递以来的所在 mvn dependency:tree -Dverbose -Dincludes=依赖的工程名:具体引发问题的包 裁剪传递 &lt;exclusion&gt;12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.unitils&lt;/groupId&gt; &lt;artifactId&gt;unitils-dbmaintainer&lt;/artifactId&gt; &lt;version&gt;$&#123;unitils.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;dbunit&lt;/artifactId&gt; &lt;groupId&gt;org.dbunit&lt;/groupId&gt; &lt;/exclusion&gt; &lt;!-- 这个就是我们要加的片断 --&gt; &lt;exclusion&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 1234== vs equals1. 是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同 2. 是指对内存地址进行比较 equals()是对字符串的内容进行比较3. 指引用是否相同 equals()指的是值是否相同]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java8</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go]]></title>
    <url>%2F2018%2F10%2F17%2FGo%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[EOS]]></title>
    <url>%2F2018%2F10%2F17%2FEOS%2F</url>
    <content type="text"><![CDATA[EOS安装使用中常见的问题一些闲话1EOS 由于其区块链行业的明星项目，ico阶段就得到了很多人的追捧完成了40多亿美元的资金。终于在今年6月份主网才磕磕绊绊的上线了，但是它并没有达到人们的预期，可用性，安全性方面都被人吐槽。用起来很蛋疼，但是没办法，人家有钱呀(有钱就是硬气)，还得硬着头皮去研究。 安装1234567891011121314151617181920212223241. git clone https://github.com/eosio/eos --recursive2. cd eos3. ./eosio_build.sh3. cd build4. sudo make install说他坑(安装都得编译源码)大家应该能猜到，安装并不会这么顺利，那我们就来总结一下这些坑1. #报错：perl: warning: Setting locale failed.perl: warning: Please check that your locale settings: LANGUAGE = (unset), LC_ALL = (unset), LC_CTYPE = "UTF-8", LANG = "en_US.UTF-8" are supported and installed on your system. # 解决方法export LANGUAGE=en_US.UTF-8export LC_ALL=en_US.UTF-8export LANG=en_US.UTF-8export LC_TYPE=en_US.UTF-82. #报错 locale::facet::_S_create_c_locale name not valid# 解决方法LANG=C 或者 export LC_ALL="en_US.UTF-8" 初始化系统1234567891011121. 创建钱包./cleos wallet create（-n + 钱包名） --to-console(将钱包密码打印到控制台) //不加 -n 参数创建默认钱包default2. cleos wallet create_key -n 钱包名 //在指定钱包中创建密钥对，不加-n 在default中创建 == ./cleos create key ./cleos import -n 钱包名称 + 私钥3. ./cleos create account $&#123;authorizing_account&#125; $&#123;new_account&#125; $&#123;owner_key&#125; $&#123;active_key&#125; // 在公网中我们无法自己创建账户，需要让其他拥有账户的帮忙创建，账户是全网唯一的，网络中的事务都是通过账户来直接完成的。私有网络中要用内置账户eosio来新建我们的以一个账户，owner_key ，active_key 指的是master和active两个不同权限级别的公玥，可以设置成一样，建议用不同的。4. 初始化系统合约./cleos set contract eosio(用户名) ../../contracts/eosio.bios -p eosio@active // 为账户eosio加载位于该路径下的合约 -p 指定该事务由哪组密钥来签署5. 初始化代币合约./cleos set contract eosioio.token ../../contracts/eosio.token -p eosio.token@active6. 发行资产./cleos push action eosio.token create '&#123;"issuer":"eosio","maximum_supply":"10000000.0000 EOS"&#125;' -p eosio.token@active // 这一步相当于印钞，还没有流通7. ./cleos push action eosio.token issue '["liyan","1000.0000 EOS","m"]' -p eosio@active // 该1000个EOS资产已经可以流通了，可用于transfer交易了8. ./cleos push action eosio.token transfer '["liyan","zzl","250.0000(精度必须带上) EOS","ysq"]' -p liyan@active //账户liyan 给 账户zzl 转了250个EOS "ysq" 相当于你发微信红包时写的备注 关于EOS的合约1EOS中，有五个基础的智能合约，分别是eosio.bios(系统初始化)、eosio.token(代币合约)、 exchange和eosio.msig(用于多用户签名和用户权限管理)、eosio.system(用户投票、将用户注册成为生产者)，了解即可。 使用中的坑123456789按照惯例，我们安装，初始化好了是不是就可以愉快地玩耍了？？？ 不可能，根本不存在！！！！1. 最让人头疼的就是 nodeos进程异常终止(断电、强杀等)尤其是主网# database dirty flag set (likely due to unclean shutdown): replay required解决方案：1. 数据量不大，不需要原来数据$ rm -rf ~/.local/share/eosio/nodeos/data/ // 删除数据目录即 --data-dir 指定的目录2. 数据量大，重新同步需要大量时间，想重用数据 $ cd /.local/share/eosio/nodeos/data/;ls blocks // 如果返回空 需要把 /.local/share/eosio/nodeos/data/下的blockXXXX重命名为blocks 然后执行下一步$ 重启时加上启动命令 --hard-replay-blockchain --replay-blockchain //(速度相当慢，没啥子卵用,v1.4.1会有所改善，wabt替换了默认的汇编解析器） 实现主网逻辑123456789101112131415161718192021222324252627281. 修改genesis.json &#123; "initial_timestamp": "2018-06-08T08:08:08.888", "initial_key": "EOS7EarnUhcyYqmdnPon8rm7mBCTnBoot6o7fE2WzjvEX2TdggbL3", "initial_configuration": &#123; "max_block_net_usage": 1048576, "target_block_net_usage_pct": 1000, "max_transaction_net_usage": 524288, "base_per_transaction_net_usage": 12, "net_usage_leeway": 500, "context_free_discount_net_usage_num": 20, "context_free_discount_net_usage_den": 100, "max_block_cpu_usage": 200000, "target_block_cpu_usage_pct": 1000, "max_transaction_cpu_usage": 150000, "min_transaction_cpu_usage": 100, "max_transaction_lifetime": 3600, "deferred_trx_expiration_window": 600, "max_transaction_delay": 3888000, "max_inline_action_size": 4096, "max_inline_action_depth": 4, "max_authority_depth": 6 &#125;&#125;2. 修改config.ini 1. 修改 chain-state-db-size 1024 --&gt; 4096 2. 添加bplist: p2p-peer-address = 159.65.214.150:98763. nohup /data/eos/build/programs/nodeos/nodeos --http-server-address 172.31.53.100:8888 --data-dir /data/eos/data --config-dir /data/eos/config --plugin eosio::chain_api_plugin --plugin eosio::history_api_plugin --plugin eosio::net_api_plugin --filter-on ****:transfer: --filter-on ******:transfer: 1&gt; /data/log/info.out 2&gt; /data/log/error.out &amp; // --filter-on 用于支持get_actions接口 私链逻辑123456789101. 修改config.ini 1. enable-stale-production = true 2. producer-name = eosio2. 启动命令跟公网类似私链初始化时可能遇到的问题# Error 3090003: Provided keys, permissions, and delays do not satisfy declared authorizations# 原因 ： 是钱包中没有账户eosio的私钥 # 解决办法 ：把eosio的私钥导入到钱包中./cleos wallet import --private-key .... 敲黑板1一定要用pkill 来终止进程，否则重放数据会消耗大量时间]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>EOS</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ethereum]]></title>
    <url>%2F2018%2F10%2F17%2Fethereum%2F</url>
    <content type="text"><![CDATA[试例程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194'use strict';const Web3 = require('web3');const Tx = require('ethereumjs-tx');const web3Admin = require('web3admin');// set the provider you want from Web3.providersvar web3 = new Web3(new Web3.providers.HttpProvider("http://192.168.112.66:8676"));//获取合约的接口ABI文件var abi = JSON.parse('[]');// 合约地址var address = '0x57eb83c23e15530cdfc8d0c0a96337743a5085b8';// 默认账户 当没有设置more账户时，发送交易不写from会报错。var coinbase = web3.eth.defaultAccount;// 获取合约实例var contract = web3.eth.contract(abi);var ContractInstance = contract.at(address);// 获取事件var event = ContractInstance.Transfer();//var TokenName = ContractInstance.name();// 产生合约实例function newContract(abi,address) &#123; var abi = JSON.parse(abi); var address = address; var contractIns = web3.eth.contract(abi).at(address); return contractIns;&#125;// 获取事件对象function newEvent(contractIns,eventFun) &#123; var event = contractIns.eventFun(); return event;&#125;// 转账/*function transfer(_to,_amount,_from,psd) &#123; // var _to = douncment.getElenmentById('').value; // var amount = douncment.getElenmentById('').value; // var _from = douncment.getElenmentById('').value; // var psd = douncment.getElenmentById('').value; if(unLockAccount(_from,psd,200))&#123; if(ContractInstance.balanceOf(_from) &gt;= _amount &amp;&amp; getbalance(_from) &gt; 0) &#123; bool = ContractInstance.transfer(_to,_amount,&#123;from:_from&#125;); if (!bool)&#123; console.log('shibai') &#125; &#125;else&#123; console.log('余额不足') &#125; &#125;else &#123; console.log('解锁失败') &#125;&#125;*/function getbalance(addr) &#123; var balance = (web3.eth.getBalance(addr)).toNumber(); return balance;&#125;function getcoinbase() &#123; return web3.eth.coinbase;&#125;function setDefaultAccount(addr)&#123; return web3.eth.defaultAccount = addr;&#125;function unLockAccount(addr,psd,time) &#123; return web3.personal.unlockAccount(addr,psd,time);&#125;function balanceOf(contact,addr) &#123; return contact.balanceOf(addr).toString();&#125;function wait_while() &#123; web3Admin.extend(web3); var pending = web3.txpool.status.pending; console.log(pending); while (pending != 0) &#123; web3.miner.start(); pending = web3.txpool.status.pending; continue; &#125; web3.miner.stop(); // console.log(web3.eth.getTransactionReceipt('0x0feee17c61d04f3a6c14e8c583fd50a62690cac446cb760e0708bd95f60eb81e'));&#125;function transfer() &#123; web3.eth.sendTransaction(&#123;from:web3.eth.accounts[0],to:web3.eth.accounts[1],value:12000&#125;,function (err,result) &#123; // wait_while(); if (err) &#123; console.log("error"); &#125; else &#123; setTimeout(function() &#123;console.log(web3.eth.getTransaction(result))&#125; ,10000) &#125; &#125;)&#125;transfer();/*function gas() &#123; web3.eth.estimateGas(&#123; to: "0x57eb83c23e15530cdfc8d0c0a96337743a5085b8", data: "0xc6888fa10000000000000000000000000000000000000000000000000000000000000003" &#125;).then(console.log);// "0x0000000000000000000000000000000000000000000000000000000000000015"&#125;// gas();function sum(arr) &#123; return arr.reduce((x, y) =&gt; &#123;return x + y&#125; )&#125;*//*console.log(getcoinbase());console.log(getbalance(web3.eth.accounts[0]));console.log(getbalance(web3.eth.accounts[2]));console.log(balanceOf(ContractInstance,web3.eth.accounts[2]));transfer(web3.eth.accounts[2],1,web3.eth.accounts[0],"");wait_while();*//*event.watch(function(error,result) &#123; if (error) &#123; console.log('出错了') &#125; else &#123; console.log(balanceOf(ContractInstance, web3.eth.accounts[2])); // console.log(balanceOf(ContractInstance, '0x00022cf5af8fa7c7999e41069cf956097ee71926')); console.log('从地址：' + '-----'+result.args.from + '转到地址:'+ '===' + result.args.to + '--------' + '代币:' + TokenName + '------' + result.args.value.toNumber() + '----' + result.transactionHash); console.log(JSON.stringify(result)); /!*web3.eth.getTransactionReceipt('0x38e5fdca6666a810f31fddb4aefee565b964459f085e2cb1870dd44cc90edc36',function (err,result) &#123; if (err) &#123; console.log("获取收据失败！！！！！！") &#125; else &#123; console.log(); &#125; &#125;)*!/ &#125;&#125;)*//*var privateKey = new Buffer('e331b6d69882b4cb4ea581d88e0b604039a3de5967688d3dcffdd2270c0fd109', 'hex')var rawTx = &#123; nonce: '0x00', gasPrice: '0x09184e72a000', gasLimit: '0x2710', to: '0x0000000000000000000000000000000000000000', value: '0x00', data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057'&#125;;var tx = new Tx(rawTx);console.log(tx);tx.sign(privateKey);var serializedTx = tx.serialize();console.log(serializedTx.toString('hex'));//f889808609184e72a00082271094000000000000000000000000000000000000000080a47f74657374320000000000000000000000000000000000000000000000000000006000571ca08a8bbf888cfa37bbf0bb965423625641fc956967b81d12e23709cead01446075a01ce999b56a8a88504be365442ea61239198e23d1fce7d00fcfc5cd3b44b7215fweb3.eth.sendRawTransaction('0x' + serializedTx.toString('hex'), function(err, hash) &#123; if (!err) console.log(hash); // "0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385"&#125;);var s = "0x7f7465737432000000000000000000000000000000000000000000000000000000600057";console.log(s.toString('hex'));var keythereum = require("keythereum");var datadir = "./";把私钥文件放在keystore的文件夹下datadir = "" // keystore的位置var address= "0x8708a326d628435a47aefcdcefa3aa2c80b7b75c";const password = "";var keyObject = keythereum.importFromFile(address, datadir);var privateKey = keythereum.recover(password, keyObject);var key = privateKey.toString('hex');console.log(key);console.log();*/ 以太坊 web3 的插件库 npm -g install web3admin geth的rpc默认情况下并不提供miner等接口，需要安装web3admin。 ethereumjs-tx 离线交易签名 keythereum 从json中解出私钥 truffle 相关命令 123456789101112truffle 安装使用truffle init 不常用了truffle compiletruffle migratetruffle unbox reacttruffle develop 使用时应该在项目目录下，因为需要读取truffle.js里的配置。truffle migrate --network live 发布到truffle.js中设置的live网络npm run startnpm run buildnpm run devnpm run server 会自动打开浏览器 remix remix 中 cmd + / 注释一行 npm install remix-ide -g 安装本地remix remix-ide 运行本地remix [ ] 当使用web3Provider模式时不能使用https!!!!!! https://remix.ethereum.org ----&gt;http://remix.ethereum.org Windows : 安装本地 remix http://remix.ethereum.org/ https://www.npmjs.com/package/remix-ide12345npm install --global --production windows-build-tools //安装依赖npm install remix-ide -g //安装 remixremix-ide //启动 ==当使用remix连接parity时，发生交易无法被parity收录时，可能的原因是账户没有解锁，当被parity收录，但无法广播到geth时，可能的原因是gasPrice为0；使用parity发送交易时，解锁一次只能发送一笔交易，当连续发送时会出现js客户端一直等待回应而进入一直阻塞的状态。中间涉及到parity客户端一个gasPrice的计算策略问题。总之交易无法广播，无外乎nonce和这总情况。==]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>ether</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2015%2F10%2F17%2FLinux%2F</url>
    <content type="text"><![CDATA[常用命令 tldr npm install -g tldr 相当于 man bat bat --language 高亮的cat 命令行基本功12345678910111213141516171819202122232425262728293031323334353637383940//linux 命令行快捷键Ctrl-A 相当于HOME键，用于将光标定位到本行最前面Ctrl-E 相当于End键，即将光标移动到本行末尾Ctrl-B 相当于左箭头键，用于将光标向左移动一格Ctrl-F 相当于右箭头键，用于将光标向右移动一格Ctrl-D 相当于Del键，即删除光标所在处的字符Ctrl-K 用于删除从光标处开始到结尾处的所有字符Ctrl-L 清屏，相当于clear命令Ctrl-R 进入历史命令查找状态，然后你输入几个关键字符，就可以找到你使用过的命令Ctrl-U 用于删除从光标开始到行首的所有字符。一般在密码或命令输入错误时常用Ctrl-H 删除光标左侧的一个字符Ctrl-W 用于删除当前光标左侧的一个单词Ctrl-P 相当于上箭头键，即显示上一个命令Ctrl-N 相当于下箭头键，即显示下一个命令Ctrl-T 用于颠倒光标所在处字符和前一个字符的位置。（目前不知道有什么作用，哪位朋友知道？）Ctrl-J 相当于回车键Alt-. 用于提取历史命令中的最后一个单词。你先执行history命令，然后再敲击此快捷键若干下，你就懂了！Alt-BackSpace 用于删除本行所有的内容，基本上和Ctrl-U类似。Alt-C 用于将当前光标处的字符变成大写，同时本光标所在单词的后续字符都变成小写。Alt-L 用于将光标所在单词及所在单词的后续字符都变成小写。Alt-U 用于将光标所在单词的光标所在处及之后的所有字符变成大写。 vim 基本功12345678910111213141516171819202122232425262728293031323334353637383940414243444546vim 快捷键j 下移动k 上移动0 移动到行首$ 移动到行末，1$表示当前行的行尾，2$表示当前行的下一行的行尾b 移动到单词的开始e 移动到单词的末尾G 移动到文档最后一行gg 移动到文档第一行v 进入光标模式，配合移动键选中多行u 撤销上一次操作dw 删除光标所在的单词dd 删除光标当前行dG 删除光标后的全部文字y 复制当前行，会复制换行符yy 复制当前行的内容yyp 复制当前行到下一行，此复制不会放到剪切板中nyy 复制当前开始的n行p 粘贴ddp 当前行和下一行互换位置(dd删除的内容会保存到粘贴板)J 合并行ZZ 保存离开* 向下查找同样光标的字符# 向上查找同样光标的字符/code 查找 code 一样的内容，向后?code 查找 code 一样的内容，向前n 查找下一处N 查找上一处ma 在光标处做一个名叫a的标记 可用26个标记 (a~z)`a 移动到一个标记ad`a 删除当前位置到标记a之间的内容:marks 查看所有标记:w filename 另存为 filename:jumps 历史编辑文档记录:set nu 设置行号显示:set nonu 取消行号显示:set 显示设置参数:set autoindent 自动缩排，回车与第一个非空格符对齐syntax on/off 根据程序语法高亮显示:set highlight 高亮设置查看:set hlsearch 查找代码高亮显示:nohlsearch 暂时关闭高亮显示:set nohlsearch 永久关闭高亮显示:set bg=dark 设置暗色调:set bg=light 设置亮色调 常用工具安装 cnetos 7安装gcc6+12345sudo yum install centos-release-sclsudo yum install devtoolset-7-gcc-c++echo &apos;source /opt/rh/devtoolset-7/enable&apos; &gt;&gt; ~/.bashrcwhich gccgcc --version 添加SHELL的TAB补全12345678Debian/Ubuntu$ apt-get install bash-completionCentos$ yum install bash-completionMAC$ brew install bash-completion centos7安装alien 转换.deb —&gt;.rpm121. yum install alien2. alien -r xxx.deb // 将.deb文件转换为 .rpm sshpass 非交互式密码管理1234567891011121314151. sshpass[下载地址](http://sourceforge.net/projects/sshpass/) 下载为一个 tar.gz的压缩包。2. tar -zxvf sshpass-1.05.tar.gz3. cd sshpass-1.054. ./configure --prefix=/opt/sshpass #指定安装目录5. make6. make install7. cp /opt/sshpass/bin/sshpass /usr/bin/ 或者把sshpass加入环境变量8. 在 iterm2 中加入profile设置 在`send Text at start` 中加入 `sshpass -p 123456 ssh user@ip` devtoolset 安装方法(devtoolset-7 链接)12345678910111213141516# 1. Install a package with repository for your system:# On CentOS, install package centos-release-scl available in CentOS repository:$ sudo yum install centos-release-scl# On RHEL, enable RHSCL repository for you system:$ sudo yum-config-manager --enable rhel-server-rhscl-7-rpms# 2. Install the collection:$ sudo yum install devtoolset-7# 3. Start using software collections:$ scl enable devtoolset-7 bash(临时)$ echo `source /opt/rh/devtoolset-7/enable` &gt;&gt; ~/.bashrc zsh123456789101112安装1. brew install zsh2. sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;~/.zshrc 加入以下内容- [高亮设置](https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md) 1. `git clone https://github.com/zsh-users/zsh-syntax-highlighting.git`2. `echo &quot;source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc`3. `source ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh` 进程与网络 lsof123456lsof命令可以列出当前的所有网络情况， 此命令的解释如下：-n 表示主机以ip地址显示 -P 表示端口以数字形式显示，默认为端口名称 -i 意义较多，具体 man lsof, 主要是用来过滤lsof的输出结果 -s 和 -i 配合使用，用于过滤输出lsof | grep port :查看占用端口的程序lsof -i:80 查看占用80端口的进程 netstat12345678netstat -antp | grep 端口号(此端口号运行的进程)+ 进程名称(此进程占用的端口号)查看连接某服务端口最多的的IP地址 netstat -ntu | grep :80 | awk &apos;&#123;print $5&#125;&apos; | cut -d: -f1 | awk &apos;&#123;++ip[$1]&#125; END &#123;for(i in ip) print ip[i],&quot;\t&quot;,i&#125;&apos; | sort -nrnetstat s |egrep &quot;listen&quot; :查看tcp全连接队列的溢出情况溢出后，系统如何处理：cat /proc/sys/net/ipv4/tcp_abort_on_overflowtcp_abort_on_overflow 为0表示如果三次握手第三步的时候全连接队列满了那么server扔掉client发过来的ack(在server端认为链接还没有建立起来)为1 表示第三步的时候如果全接队列满了，server发送一个reset包给client，表示废弃这个握手过程 nc12345678nc（netcat）:- 端口扫描nc -z -v -n 127.0.0.1 21-25参数详解： -z :连接成功后立即关闭连接，不进行数据交换-v : 详细输出-n :不使用DNS解析(使用使用域名时，不加该参数-u : -u参数调整为udp,默认为TCP) telnet telnet ip 空格代替冒号 port curl123curl -X POST -H 'Expect:' -d @aa.txt http://192.168.101.7:52433/com.xxx.api.LoanApplyService:1.0.0/loanApply --header 'Expect:'会去掉curl对参数长度1024的限制 -d@aa.txt 指定使用aa.txt中的内容作为参数 ssh 公玥认证1231. ssh-keygen -t rsa2. ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub3. ssh ubuntu@118.89.235.114 ssh 私钥登录1ssh -i 私钥文件路径 root@192.168.112.80 跨服务器拷贝123456跨服务器传输文件 SCPscp [参数] [文件原路径] [目标路径]- 远程 - 本地 scp root@ip:/path /localpath- 本地 -- 远程 scp localpath root@ip:/pathrsync shell 技巧 (),(()),[],[[]]12345678$(linux 命令) - 得到命令的执行结果，可以作为其他命令的参数 等同于``(反单引号) - 命令组 括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用(()) -用于算数运算符比较 eg: if (($i&lt;5)), 如果不使用双括号, 则为if [ $i -lt 5 ][] 相当于test 里面的合法的比较运算符 只有==和！= 不能使用` &gt; &lt; &gt;= &lt;=`[[]] 没有上面[]的限制 程序安装及依赖检测12345678yum -y localinstall xxx.rpm // 安装的同时解决依赖问题brew（mac） yum(linux) wget(centos) apt-get(ubantu) 应用下载工具rpm -ivh 安装rpm -Uvh 更新rpm -e 卸载ldd 程序名称 查看程序的运行依赖 杂项 pv (pipe-view) 查看命令执行的进度123456789101112131. 监视打开/拷贝文件进度pv /media/himanshu/1AC2-A8E3/fNf.mkv &gt; ./Desktop/fnf.mkv-p 显示进度-t 显示时间-n 显示整数百分比-r 速率-e 估计剩余的时间-L 修改传输速率 pv -L 2m /media/himanshu/1AC2-A8E3/fNf.mkv &gt; ./Desktop/fnf.mkv2. 监视压缩文件进度pv /media/himanshu/1AC2-A8E3/fnf.mkv | gzip &gt; ./Desktop/fnf.log.gz3. 监视数据内容搜索进度 pv -L 5k pvtest.dat | wc 常用命令1234567891011121314151617181920212223242526272829303132pkill + 进程进程名 按进程名字结束进程(会杀死同名的所有进程) == killallkillall + 进程名称 查看实时资源占用：top M(内存倒序) P(CPU倒序)ss 显示处于活动状态的套接字信息ss -lnt : l(listen) n(不解析服务器名称) t(tcp)ps aux/-ef |grep xxx 查看进程信息ps aux | grep xxx | grep -v grep | xargs（将输入转化为后面命令的参数） kill -9 === kill -9 ` ps -aux |grep xxx |grep -v grep | awk '&#123;print $2&#125;' `== kill -9 $(ps -aux |grep xxx |grep -v grep | awk '&#123;print $2&#125;')grep -v x'x'x 反选 不包含x'x'x 的结果 pgrep 通过程序的名字来查询进程egrep 在指定文件中查找指定字符串xargs 还有指定参数位置的作用。假设我们要将目录下所有的.py文件放到Python目录中去，可以使用命令find . -name '*.py' | xargs -I &#123;&#125; mv &#123;&#125; ./Python参数-I指定了管道前命令作为参数所应该在管道后面命令的位置find / -name filename 查看文件路径tar -cf 压缩tar -xf 解压unzip cd - 返回上次访问的目录df -h 可以获取硬盘被占用了多少空间，目前还剩下多少空间等信息du -h 查看指定文件，文件夹所占用的磁盘空间fdisk 分区后台启动：nohup + 应用启动命令 + &amp;bg , fg , ctrl +z , jobsctrl +z ： 把当前进程挂起ctrl +c ：结束当前进程 == kill -15nslookup(host) - 域名与ip互查init 6 重启uptime 查看系统负载时间ipcs 进程间通信信息 iterm2 使用rz(下载) sz（上传） brew install lrzsz cd ／usr/local/bin sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh sudo chmod 777 /usr/local/bin/iterm2-* 添加触发器 打开Item2，点击preferences → profiles，选择某个profile，如Default，之后继续选择advanced → triggers，添加编辑添加如下triggers： rz waiting to receive. 可以不加 Regular Expression Action Parameters rz waiting to receive.\\B0100 Run Silent Coprocess /usr/local/bin/iterm2-send-zmodem.sh \\B00000000000000 Run Silent Coprocess /usr/local/bin/iterm2-recv-zmodem.sh 终端输出颜色123\033[字背景颜色;字体颜色m字符串\033[0m字体背景色数值 40 - 49（可省略）字体颜色数值 30 - 39 32位 vs 64 位 123451. 32位操作系统针对的32位的CPU设计。2. 64位操作系统针对的64位的CPU设计。3. 32位的CPU一次(可能包含多个指令)只能处理32位的数据(即4个字节称为一个机器字)4. 同理，64位CPU一次能处理64的数据(即8个字节的数据)5. 所以32位的一个机器字位4个字节，64位的一个机器字位8个字节 防火墙相关123456789101112131415161718192021222324252627282930313233343536firewall-cmd --state '查看防火墙状态'systemctl status firewalld.servicesystemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动iptables服务命令-- 启动服务# /etc/init.d/iptables start # service iptables start-- 停止服务# /etc/init.d/iptables stop# service iptables stop-- 重启服务# /etc/init.d/iptables restart# service iptables restart-- 保存设置# /etc/init.d/iptables save# service iptables save2. 配置Filter表防火墙 1. 查看iptables的配置信息# iptables -L -n 1. 清除原有防火墙规则 清除预设表filter中的所有规则链的规则# iptables -F 清除预设表filter中使用者自定链中的规则# iptables -X 保存防火墙设置# /etc/init.d/iptables save或# service iptables save 防火墙过滤规则123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108请求接入包丢弃[root@home ~]# iptables -p INPUT DROP接受响应数据包[root@home ~]# iptables -p OUTPUT ACCEPT转发数据包丢弃 [root@home ~]# iptables -p FORWARD DROP 添加防火墙规则 首先添加INPUT链,INPUT链的默认规则是DROP,所以我们就写需要ACCETP(通过)的链。 开启SSH服务端口[root@tp ~]# iptables -A INPUT -p tcp --dport 22 -j ACCEPT[root@tp ~]# iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT 注:如果在预设设置把OUTPUT设置成DROP策略的话，就需要设置OUTPUT规则，否则无法进行SSH连接。 开启Web服务端口[root@tp ~]# iptables -A OUTPUT -p tcp --sport 80 -j ACCEPT[root@tp ~]# iptables -A INPUT -p tcp --dport 80 -j ACCEPT 开启邮件服务的25、110端口[root@tp ~]# iptables -A INPUT -p tcp --dport 110 -j ACCEPT[root@tp ~]# iptables -A INPUT -p tcp --dport 25 -j ACCEPT 开启FTP服务的21端口[root@tp ~]# iptables -A INPUT -p tcp --dport 21 -j ACCEPT[root@tp ~]# iptables -A INPUT -p tcp --dport 20 -j ACCEPT 开启DNS服务的53端口[root@tp ~]# iptables -A INPUT -p tcp --dport 53 -j ACCEPT 设置icmp服务[root@tp ~]# iptables -A OUTPUT -p icmp -j ACCEPT (OUTPUT设置成DROP的话)[root@tp ~]# iptables -A INPUT -p icmp -j ACCEPT (INPUT设置成DROP的话) 允许loopback不然会导致DNS无法正常关闭等问题[root@tp ~]# IPTABLES -A INPUT -i lo -p all -j ACCEPT (如果是INPUT DROP)[root@tp ~]# IPTABLES -A OUTPUT -o lo -p all -j ACCEPT(如果是OUTPUT DROP) 减少不安全的端口连接[root@tp ~]# iptables -A OUTPUT -p tcp --sport 31337 -j DROP[root@tp ~]# iptables -A OUTPUT -p tcp --dport 31337 -j DROP说明：有些特洛伊木马会扫描端口31337到31340(即黑客语言中的 elite 端口)上的服务。既然合法服务都不使用这些非标准端口来通信,阻塞这些端口能够有效地减少你的网络上可能被感染的机器和它们的远程主服务器进行独立通信的机会。此外，其他端口也一样,像:31335、27444、27665、20034 NetBus、9704、137-139（smb）,2049(NFS)端口也应被禁止。 只允许某台主机或某个网段进行SSH连接只允许192.168.0.3的机器进行SSH连接[root@tp ~]# iptables -A INPUT -s 192.168.0.3 -p tcp --dport 22 -j ACCEPT如果允许或限制一段IP地址可用192.168.0.0/24表示192.168.0.1-255端的所有IP, 24表示子网掩码数。[root@tp ~]# iptables -A INPUT -s 192.168.0.0/24 -p tcp --dport 22 -j ACCEPT注意：指定某个主机或者某个网段进行SSH连接，需要在iptables配置文件中的-A INPUT -p tcp -m tcp --dport 22 -j ACCEPT删除，因为它表示所有地址都可以登陆.如果只允许除了192.168.0.3的主机外都能进行SSH连接[root@tp ~]# iptables -A INPUT -s ! 192.168.0.3 -p tcp --dport 22 -j ACCEPT 开启转发功能在做NAT网络配置时,FORWARD默认规则是DROP时,必须开启数据包转发功能[root@tp ~]# iptables -A FORWARD -i eth0 -o eth1 -m state --state RELATED,ESTABLISHED -j ACCEPT[root@tp ~]# iptables -A FORWARD -i eth1 -o eh0 -j ACCEPT 丢弃坏的TCP包[root@tp ~]#iptables -A FORWARD -p TCP ! --syn -m state --state NEW -j DROP 处理IP碎片数量，防止DDOS攻击，允许每秒100个[root@tp ~]#iptables -A FORWARD -f -m limit --limit 100/s --limit-burst 100 -j ACCEPT 设置ICMP包过滤, 允许每秒1个包, 限制触发条件是10个包[root@tp ~]#iptables -A FORWARD -p icmp -m limit --limit 1/s --limit-burst 10 -j ACCEPT DROP非法连接[root@tp ~]# iptables -A INPUT -m state --state INVALID -j DROP[root@tp ~]# iptables -A OUTPUT -m state --state INVALID -j DROP[root@tp ~]# iptables -A FORWARD -m state --state INVALID -j DROP 允许所有已经建立的和相关的连接[root@tp ~]# iptables-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT[root@tp ~]# iptables-A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT[root@tp ~]# /etc/rc.d/init.d/iptables save3. 配置NAT表防火墙 1. 查看本机关于NAT的设置情况[root@tp rc.d]# iptables -t nat -L 1. 清除NAT规则[root@tp ~]# iptables -F -t nat[root@tp ~]# iptables -X -t nat[root@tp ~]# iptables -Z -t nat1. 添加规则添加基本的NAT地址转换，添加规则时，我们只添加DROP链，因为默认链全是ACCEPT。防止外网用内网IP欺骗[root@tp sysconfig]# iptables -t nat -A PREROUTING -i eth0 -s 10.0.0.0/8 -j DROP[root@tp sysconfig]# iptables -t nat -A PREROUTING -i eth0 -s 172.16.0.0/12 -j DROP[root@tp sysconfig]# iptables -t nat -A PREROUTING -i eth0 -s 192.168.0.0/16 -j DROP禁止与211.101.46.253的所有连接[root@tp ~]# iptables -t nat -A PREROUTING -d 211.101.46.253 -j DROP禁用FTP(21)端口[root@tp ~]# iptables -t nat -A PREROUTING -p tcp --dport 21 -j DROP只禁用211.101.46.253地址的FTP连接,其他连接可以进行。[root@tp ~]# iptables -t nat -A PREROUTING -p tcp --dport 21 -d 211.101.46.253 -j DROP​```]]></content>
      <categories>
        <category>categories</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
</search>
